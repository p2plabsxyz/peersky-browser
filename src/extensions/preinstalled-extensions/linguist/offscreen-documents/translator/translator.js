(()=>{"use strict";var __webpack_modules__={7584:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{b:()=>loadTranslator});const loadTranslator=code=>{const translatorClass=eval(code);if("function"!=typeof translatorClass)throw new TypeError("Type of object must be callable");let instance;try{instance=new translatorClass}catch(e){throw console.error(e),new Error("Error while create instance of translator")}const requiredMethods=["translate","translateBatch","getLengthLimit"];requiredMethods.forEach(e=>{if(!(e in instance))throw new TypeError(`Translator method "${e}" is not defined`);if("function"!=typeof instance[e])throw new TypeError(`Translator instance member "${e}" is not a function`)});const requiredStaticMethods=["isSupportedAutoFrom","getSupportedLanguages"];return requiredStaticMethods.forEach(e=>{if(!(e in translatorClass))throw new TypeError(`Translator static method "${e}" is not defined`);if("function"!=typeof translatorClass[e])throw new TypeError(`Translator static member "${e}" is not a function`)}),translatorClass}}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](r,r.exports,__webpack_require__),r.exports}__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var __webpack_exports__={},enums_MessageType,Resolution,enums_ErrorCode,NativeErrorName,enums_NativeEventType;!function(e){e.Call="call",e.Reply="reply",e.Syn="syn",e.SynAck="synAck",e.Ack="ack"}(enums_MessageType||(enums_MessageType={})),function(e){e.Fulfilled="fulfilled",e.Rejected="rejected"}(Resolution||(Resolution={})),function(e){e.ConnectionDestroyed="ConnectionDestroyed",e.ConnectionTimeout="ConnectionTimeout",e.NoIframeSrc="NoIframeSrc"}(enums_ErrorCode||(enums_ErrorCode={})),function(e){e.DataCloneError="DataCloneError"}(NativeErrorName||(NativeErrorName={})),function(e){e.Message="message"}(enums_NativeEventType||(enums_NativeEventType={}));const DEFAULT_PORT_BY_PROTOCOL={"http:":"80","https:":"443"},URL_REGEX=/^(https?:)?\/\/([^/:]+)?(:(\d+))?/,opaqueOriginSchemes=null,parent_getOriginFromSrc=e=>{if(e&&opaqueOriginSchemes.find(t=>e.startsWith(t)))return"null";const t=document.location,r=URL_REGEX.exec(e);let n,o,a;return r?(n=r[1]?r[1]:t.protocol,o=r[2],a=r[4]):(n=t.protocol,o=t.hostname,a=t.port),`${n}//${o}${a&&a!==DEFAULT_PORT_BY_PROTOCOL[n]?`:${a}`:""}`},serializeError=({name:e,message:t,stack:r})=>({name:e,message:t,stack:r}),deserializeError=e=>{const t=new Error;return Object.keys(e).forEach(r=>t[r]=e[r]),t},lib_connectCallReceiver=(e,t,r)=>{const{localName:n,local:o,remote:a,originForSending:s,originForReceiving:i}=e;let c=!1;const l=e=>{if(e.source!==a||e.data.penpal!==enums_MessageType.Call)return;if("*"!==i&&e.origin!==i)return void r(`${n} received message from origin ${e.origin} which did not match expected origin ${i}`);const o=e.data,{methodName:l,args:d,id:u}=o;r(`${n}: Received ${l}() call`);const p=e=>t=>{if(r(`${n}: Sending ${l}() reply`),c)return void r(`${n}: Unable to send ${l}() reply due to destroyed connection`);const o={penpal:enums_MessageType.Reply,id:u,resolution:e,returnValue:t};e===Resolution.Rejected&&t instanceof Error&&(o.returnValue=serializeError(t),o.returnValueIsError=!0);try{a.postMessage(o,s)}catch(e){if(e.name===NativeErrorName.DataCloneError){const t={penpal:enums_MessageType.Reply,id:u,resolution:Resolution.Rejected,returnValue:serializeError(e),returnValueIsError:!0};a.postMessage(t,s)}throw e}};new Promise(e=>e(t[l].apply(t,d))).then(p(Resolution.Fulfilled),p(Resolution.Rejected))};return o.addEventListener(enums_NativeEventType.Message,l),()=>{c=!0,o.removeEventListener(enums_NativeEventType.Message,l)}};let id=0;const generateId=()=>++id,KEY_PATH_DELIMITER=".",keyPathToSegments=e=>e?e.split(KEY_PATH_DELIMITER):[],segmentsToKeyPath=e=>e.join(KEY_PATH_DELIMITER),createKeyPath=(e,t)=>{const r=keyPathToSegments(t||"");return r.push(e),segmentsToKeyPath(r)},setAtKeyPath=(e,t,r)=>{const n=keyPathToSegments(t);return n.reduce((e,t,o)=>(void 0===e[t]&&(e[t]={}),o===n.length-1&&(e[t]=r),e[t]),e),e},methodSerialization_serializeMethods=(e,t)=>{const r={};return Object.keys(e).forEach(n=>{const o=e[n],a=createKeyPath(n,t);"object"==typeof o&&Object.assign(r,methodSerialization_serializeMethods(o,a)),"function"==typeof o&&(r[a]=o)}),r},deserializeMethods=e=>{const t={};for(const r in e)setAtKeyPath(t,r,e[r]);return t},lib_connectCallSender=(e,t,r,n,o)=>{const{localName:a,local:s,remote:i,originForSending:c,originForReceiving:l}=t;let d=!1;o(`${a}: Connecting call sender`);const u=r.reduce((e,t)=>{var r;return e[t]=(r=t,(...e)=>{let t;o(`${a}: Sending ${r}() call`);try{i.closed&&(t=!0)}catch(e){t=!0}if(t&&n(),d){const e=new Error(`Unable to send ${r}() call due to destroyed connection`);throw e.code=enums_ErrorCode.ConnectionDestroyed,e}return new Promise((t,n)=>{const d=generateId(),u=e=>{if(e.source!==i||e.data.penpal!==enums_MessageType.Reply||e.data.id!==d)return;if("*"!==l&&e.origin!==l)return void o(`${a} received message from origin ${e.origin} which did not match expected origin ${l}`);const c=e.data;o(`${a}: Received ${r}() reply`),s.removeEventListener(enums_NativeEventType.Message,u);let p=c.returnValue;c.returnValueIsError&&(p=deserializeError(p)),(c.resolution===Resolution.Fulfilled?t:n)(p)};s.addEventListener(enums_NativeEventType.Message,u);const p={penpal:enums_MessageType.Call,id:d,methodName:r,args:e};i.postMessage(p,c)})}),e},{});return Object.assign(e,deserializeMethods(u)),()=>{d=!0}},parent_handleAckMessageFactory=(e,t,r,n,o)=>{const{destroy:a,onDestroy:s}=n;let i,c;const l={};return n=>{if("*"!==t&&n.origin!==t)return void o(`Parent: Handshake - Received ACK message from origin ${n.origin} which did not match expected origin ${t}`);o("Parent: Handshake - Received ACK");const d={localName:"Parent",local:window,remote:n.source,originForSending:r,originForReceiving:t};i&&i(),i=connectCallReceiver(d,e,o),s(i),c&&c.forEach(e=>{delete l[e]}),c=n.data.methodNames;const u=connectCallSender(l,d,c,a,o);return s(u),l}},parent_handleSynMessageFactory=(e,t,r,n)=>o=>{if(!o.source)return;if("*"!==r&&o.origin!==r)return void e(`Parent: Handshake - Received SYN message from origin ${o.origin} which did not match expected origin ${r}`);e("Parent: Handshake - Received SYN, responding with SYN-ACK");const a={penpal:MessageType.SynAck,methodNames:Object.keys(t)};o.source.postMessage(a,n)},lib_startConnectionTimeout=(e,t)=>{let r;return void 0!==e&&(r=window.setTimeout(()=>{const r=new Error(`Connection timed out after ${e}ms`);r.code=enums_ErrorCode.ConnectionTimeout,t(r)},e)),()=>{clearTimeout(r)}},parent_validateIframeHasSrcOrSrcDoc=e=>{if(!e.src&&!e.srcdoc){const e=new Error("Iframe must have src or srcdoc property defined.");throw e.code=ErrorCode.NoIframeSrc,e}},connectToChild=e=>{let{iframe:t,methods:r={},childOrigin:n,timeout:o,debug:a=!1}=e;const s=createLogger(a),i=createDestructor("Parent",s),{onDestroy:c,destroy:l}=i;n||(validateIframeHasSrcOrSrcDoc(t),n=getOriginFromSrc(t.src));const d="null"===n?"*":n,u=serializeMethods(r),p=handleSynMessageFactory(s,u,n,d),_=handleAckMessageFactory(u,n,d,i,s);return{promise:new Promise((e,r)=>{const n=startConnectionTimeout(o,l),a=r=>{if(r.source===t.contentWindow&&r.data)if(r.data.penpal!==MessageType.Syn){if(r.data.penpal===MessageType.Ack){const t=_(r);return void(t&&(n(),e(t)))}}else p(r)};window.addEventListener(NativeEventType.Message,a),s("Parent: Awaiting handshake"),monitorIframeRemoval(t,i),c(e=>{window.removeEventListener(NativeEventType.Message,a),e&&r(e)})}),destroy(){l()}}},lib_createDestructor=(e,t)=>{const r=[];let n=!1;return{destroy(o){n||(n=!0,t(`${e}: Destroying connection`),r.forEach(e=>{e(o)}))},onDestroy(e){n?e():r.push(e)}}},lib_createLogger=e=>(...t)=>{e&&console.log("[Penpal]",...t)},handleSynAckMessageFactory=(e,t,r,n)=>{const{destroy:o,onDestroy:a}=r;return r=>{if(!(e instanceof RegExp?e.test(r.origin):"*"===e||e===r.origin))return void n(`Child: Handshake - Received SYN-ACK from origin ${r.origin} which did not match expected origin ${e}`);n("Child: Handshake - Received SYN-ACK, responding with ACK");const s="null"===r.origin?"*":r.origin,i={penpal:enums_MessageType.Ack,methodNames:Object.keys(t)};window.parent.postMessage(i,s);const c={localName:"Child",local:window,remote:window.parent,originForSending:s,originForReceiving:r.origin},l=lib_connectCallReceiver(c,t,n);a(l);const d={},u=lib_connectCallSender(d,c,r.data.methodNames,o,n);return a(u),d}},areGlobalsAccessible=()=>{try{clearTimeout()}catch(e){return!1}return!0},connectToParent=(e={})=>{const{parentOrigin:t="*",methods:r={},timeout:n,debug:o=!1}=e,a=lib_createLogger(o),s=lib_createDestructor("Child",a),{destroy:i,onDestroy:c}=s,l=methodSerialization_serializeMethods(r),d=handleSynAckMessageFactory(t,l,s,a);return{promise:new Promise((e,r)=>{const o=lib_startConnectionTimeout(n,i),s=t=>{if(areGlobalsAccessible()&&t.source===parent&&t.data&&t.data.penpal===enums_MessageType.SynAck){const r=d(t);r&&(window.removeEventListener(enums_NativeEventType.Message,s),o(),e(r))}};window.addEventListener(enums_NativeEventType.Message,s),(()=>{a("Child: Handshake - Sending SYN");const e={penpal:enums_MessageType.Syn},r=t instanceof RegExp?"*":t;window.parent.postMessage(e,r)})(),c(e=>{window.removeEventListener(enums_NativeEventType.Message,s),e&&r(e)})}),destroy(){i()}}};var loadTranslator=__webpack_require__(7584);let translator=null;const connection=connectToParent({methods:{async init(e){const t=(0,loadTranslator.b)(e);return translator=new t,{autoFrom:t?.isSupportedAutoFrom()??!1,supportedLanguages:t?.getSupportedLanguages()??[],maxTextLength:translator?.getLengthLimit()??5e3,timeout:translator?.getRequestsTimeout()??50}},async translate(e,t,r){if(!translator)throw new Error("Translator is not defined");return translator.translate(e,t,r)},async translateBatch(e,t,r){if(!translator)throw new Error("Translator is not defined");return translator.translateBatch(e,t,r)}}});window.fetch=async(e,t={})=>connection.promise.then(r=>r.fetch(e,t).then(({body:e,...t})=>new Response(e,t)))})();